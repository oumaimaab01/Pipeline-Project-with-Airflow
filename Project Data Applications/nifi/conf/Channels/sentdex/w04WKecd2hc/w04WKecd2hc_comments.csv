author,updated_at,like_count,text,public
@JmanBC,2023-11-26T01:58:23Z,0,"Code for Python 3.11  import matplotlib.pyplot as plt import matplotlib.ticker as mticker import matplotlib.dates as mdates import numpy as np from matplotlib import style import time from functools import reduce  style.use(""ggplot"")  totalStart = time.time()  date,bid,ask = np.genfromtxt('GBPUSD1d.txt', unpack=True,                               delimiter=',',                               converters={0: mdates.datestr2num})  avgLine = ((bid+ask)/2)  patternAr = [] performanceAr = [] patForRec = [] patForRec = []  def percentChange(startPoint,currentPoint):     try:         x = ((float(currentPoint)-float(startPoint))/abs(startPoint))*100.00         if x == 0.0:             return 0.000000001         else:             return x     except:         return 0.0001  def patternStorage():     '''     The goal of patternFinder is to begin collection of %change patterns     in the tick data. From there, we also collect the short-term outcome     of this pattern. Later on, the length of the pattern, how far out we     look to compare to, and the length of the compared range be changed,     and even THAT can be machine learned to find the best of all 3 by     comparing success rates.     '''      startTime = time.time()          x = len(avgLine)-30     y = 11     currentStance = 'none'          while y < x:         pattern = []         p1 = percentChange(avgLine[y-10], avgLine[y-9])         p2 = percentChange(avgLine[y-10], avgLine[y-8])         p3 = percentChange(avgLine[y-10], avgLine[y-7])         p4 = percentChange(avgLine[y-10], avgLine[y-6])         p5 = percentChange(avgLine[y-10], avgLine[y-5])         p6 = percentChange(avgLine[y-10], avgLine[y-4])         p7 = percentChange(avgLine[y-10], avgLine[y-3])         p8 = percentChange(avgLine[y-10], avgLine[y-2])         p9 = percentChange(avgLine[y-10], avgLine[y-1])         p10= percentChange(avgLine[y-10], avgLine[y])          outcomeRange = avgLine[y+20:y+30]         currentPoint = avgLine[y]          try:             avgOutcome = reduce(lambda x, y: x + y, outcomeRange) / len(outcomeRange)         except Exception as e:             print (str(e))             avgOutcome = 0         futureOutcome = percentChange(currentPoint, avgOutcome)          '''         print 'where we are historically:',currentPoint         print 'soft outcome of the horizon:',avgOutcome         print 'This pattern brings a future change of:',futureOutcome         print '_______'         print p1, p2, p3, p4, p5, p6, p7, p8, p9, p10         '''          pattern.append(p1)         pattern.append(p2)         pattern.append(p3)         pattern.append(p4)         pattern.append(p5)         pattern.append(p6)         pattern.append(p7)         pattern.append(p8)         pattern.append(p9)         pattern.append(p10)           patternAr.append(pattern)         performanceAr.append(futureOutcome)                  y+=1         #####         endTime = time.time()         print (len(patternAr))         print (len(performanceAr))         print ('Pattern storing took:', endTime-startTime)         #####   #### ####  def currentPattern():     mostRecentPoint = avgLine[-1]      cp1 = percentChange(avgLine[-11],avgLine[-10])     cp2 = percentChange(avgLine[-11],avgLine[-9])     cp3 = percentChange(avgLine[-11],avgLine[-8])     cp4 = percentChange(avgLine[-11],avgLine[-7])     cp5 = percentChange(avgLine[-11],avgLine[-6])     cp6 = percentChange(avgLine[-11],avgLine[-5])     cp7 = percentChange(avgLine[-11],avgLine[-4])     cp8 = percentChange(avgLine[-11],avgLine[-3])     cp9 = percentChange(avgLine[-11],avgLine[-2])     cp10= percentChange(avgLine[-11],avgLine[-1])      patForRec.append(cp1)     patForRec.append(cp2)     patForRec.append(cp3)     patForRec.append(cp4)     patForRec.append(cp5)     patForRec.append(cp6)     patForRec.append(cp7)     patForRec.append(cp8)     patForRec.append(cp9)     patForRec.append(cp10)      #print (patForRec)       def graphRawFX():     fig=plt.figure(figsize=(10,7))     ax1 = plt.subplot2grid((40,40), (0,0), rowspan=40, colspan=40)     ax1.plot(date,bid)     ax1.plot(date,ask)     ax1.plot(date,percentChange(ask[0],ask),'r')     ax1.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d %H:%M:%S'))     plt.grid(True)     for label in ax1.xaxis.get_ticklabels():             label.set_rotation(45)     plt.gca().get_yaxis().get_major_formatter().set_useOffset(False)     ax1_2 = ax1.twinx()     ax1_2.fill_between(date, 0, (ask-bid), facecolor='g',alpha=.3)      plt.subplots_adjust(bottom=.23)       plt.show()   def patternRecognition():     for eachPattern in patternAr:         sim1 = 100.00 - abs(percentChange(eachPattern[0], patForRec[0]))         sim2 = 100.00 - abs(percentChange(eachPattern[1], patForRec[1]))         sim3 = 100.00 - abs(percentChange(eachPattern[2], patForRec[2]))         sim4 = 100.00 - abs(percentChange(eachPattern[3], patForRec[3]))         sim5 = 100.00 - abs(percentChange(eachPattern[4], patForRec[4]))         sim6 = 100.00 - abs(percentChange(eachPattern[5], patForRec[5]))         sim7 = 100.00 - abs(percentChange(eachPattern[6], patForRec[6]))         sim8 = 100.00 - abs(percentChange(eachPattern[7], patForRec[7]))         sim9 = 100.00 - abs(percentChange(eachPattern[8], patForRec[8]))         sim10 = 100.00 - abs(percentChange(eachPattern[9], patForRec[9]))         howSim = (sim1+sim2+sim3+sim4+sim5+sim6+sim7+sim8+sim9+sim10)/10.00          if howSim > 70:             patdex = patternAr.index(eachPattern)             print (patdex)                          print ('##################################')             print ('##################################')             xp = [1,2,3,4,5,6,7,8,9,10]             fig = plt.figure()             plt.plot(xp, patForRec)             plt.plot(xp, eachPattern)             plt.show()             print (patForRec)             print ('===================================')             print ('===================================')             print (eachPattern)             print ('----------')             print ('predicted outcome:',performanceAr[patdex])             print ('##################################')             print ('##################################')                        patternStorage() currentPattern() patternRecognition() totalEnd = time.time()-totalStart print ('Entire processing took:',totalEnd,'seconds')",True
@harsharora6469,2016-12-07T06:39:15Z,0,"hi,  Will you please help- to explain the basic concept behind this . how you are predicting the patterns .  Thanks",True
@Semnomic,2016-07-04T18:22:00Z,0,Hi nice videos :) quick Q when you plot the graphs we see the start is more similar than the ends? (you mention divergence etc)  I see why your program does it this way.  Would it not be better to look up and compare your patterns in reverse ? so the endings (points on right) are the most similar ?   I think the last points are more relevant than the older ones (on left) NO!! ?  please explain why you do it this way.  Thanks,True
@YESYESYESYESYEYSYES,2014-09-02T01:03:18Z,0,"I get this error =============  Traceback (most recent call last):   File ""C:\Python27\ANN.py"", line 171, in <module>     patternRecognition()   File ""C:\Python27\ANN.py"", line 135, in patternRecognition     plt.plot(xp, eachPattern)   File ""C:\Python27\lib\site-packages\matplotlib\pyplot.py"", line 3093, in plot     ret = ax.plot(*args, **kwargs)   File ""C:\Python27\lib\site-packages\matplotlib\axes\_axes.py"", line 1373, in plot     for line in self._get_lines(*args, **kwargs):   File ""C:\Python27\lib\site-packages\matplotlib\axes\_base.py"", line 303, in _grab_next_args     for seg in self._plot_args(remaining, kwargs):   File ""C:\Python27\lib\site-packages\matplotlib\axes\_base.py"", line 281, in _plot_args     x, y = self._xy_from_xy(x, y)   File ""C:\Python27\lib\site-packages\matplotlib\axes\_base.py"", line 223, in _xy_from_xy     raise ValueError(""x and y must have same first dimension"") ValueError: x and y must have same first dimension",True
@antoniozeus4,2013-12-14T19:25:00Z,0,"is the y-axis pips and the x-axis the amount of points we are looking at? also, does the graph show us that once a pattern is found, GBPUSD usually turns down (declines)",True
@sentdex,2013-10-25T18:55:50Z,4,"Watching the full ad does help me since my account is monetized. That said, only do it if you actually are interested in the ad. If you do that, you'll hopefully get ones you care about. If that's none of the ads, then don't worry about it. I use the income to help keep my business afloat in its young age, but I also do this because I just plain enjoy it. Thanks for asking, that's very kind of you to care about that.",True
@doucheron,2013-10-25T18:04:00Z,0,"quick question (unrelated to the tutorial content):  As I'm watching these videos, does it matter--assuming I'm not clicking on them--whether I watch the entire promotional content before your tutorial begins?  If it is somehow helping you, then I have no problem with letting the entire 30 second advert. run, but if it makes no difference either way then I'm going to hit 'skip this add' as soon as I have the option.",True
