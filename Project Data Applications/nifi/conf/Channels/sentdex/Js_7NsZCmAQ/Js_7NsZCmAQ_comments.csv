author,updated_at,like_count,text,public
@JmanBC,2023-11-26T01:19:02Z,0,"Python 3.11 code  import matplotlib.pyplot as plt import matplotlib.ticker as mticker import matplotlib.dates as mdates import numpy as np from matplotlib import style import time from functools import reduce  style.use(""ggplot"")  date,bid,ask = np.genfromtxt('D:\Python\data\GBPUSD1d.txt', unpack=True,                               delimiter=',',                               converters={0: mdates.datestr2num})  avgLine = ((bid+ask)/2)  ####DEFINE###### #CHANGE# patternAr = [] performanceAr = [] patForRec = []   def percentChange(startPoint,currentPoint):     try:         return (((currentPoint)-startPoint)/abs(startPoint))*100.00     except:         return 0  def patternStorage():     '''     The goal of patternFinder is to begin collection of %change patterns     in the tick data. From there, we also collect the short-term outcome     of this pattern. Later on, the length of the pattern, how far out we     look to compare to, and the length of the compared range be changed,     and even THAT can be machine learned to find the best of all 3 by     comparing success rates.     '''     ####     startTime = time.time()     # required to do a pattern array, because the liklihood of an identical     # %change across millions of patterns is fairly likely and would     # cause problems. IF it was a problem of identical patterns,     # then it wouldnt matter, but the % change issue     # would cause a lot of harm. Cannot have a list as a dictionary Key.          #MOVE THE ARRAYS THEMSELVES#          x = len(avgLine)-30     y = 11     currentStance = 'none'          while y < x:         pattern = []         p1 = percentChange(avgLine[y-10], avgLine[y-9])         p2 = percentChange(avgLine[y-10], avgLine[y-8])         p3 = percentChange(avgLine[y-10], avgLine[y-7])         p4 = percentChange(avgLine[y-10], avgLine[y-6])         p5 = percentChange(avgLine[y-10], avgLine[y-5])         p6 = percentChange(avgLine[y-10], avgLine[y-4])         p7 = percentChange(avgLine[y-10], avgLine[y-3])         p8 = percentChange(avgLine[y-10], avgLine[y-2])         p9 = percentChange(avgLine[y-10], avgLine[y-1])         p10= percentChange(avgLine[y-10], avgLine[y])          outcomeRange = avgLine[y+20:y+30]         currentPoint = avgLine[y]         #Define##########################         #########change to try except for safety         try:             avgOutcome = reduce(lambda x, y: x + y, outcomeRange) / len(outcomeRange)         except Exception as e:             print (str(e))             avgOutcome = 0         #Define         futureOutcome = percentChange(currentPoint, avgOutcome)          #print some logics         '''         print 'where we are historically:',currentPoint         print 'soft outcome of the horizon:',avgOutcome         print 'This pattern brings a future change of:',futureOutcome         print '_______'         print p1, p2, p3, p4, p5, p6, p7, p8, p9, p10         '''          pattern.append(p1)         pattern.append(p2)         pattern.append(p3)         pattern.append(p4)         pattern.append(p5)         pattern.append(p6)         pattern.append(p7)         pattern.append(p8)         pattern.append(p9)         pattern.append(p10)           #can use .index to find the index value, then search for that value to get the matching information.         # so like, performanceAr.index(12341)         patternAr.append(pattern)         performanceAr.append(futureOutcome)                  y+=1         #####         endTime = time.time()         print (len(patternAr))         print (len(performanceAr))         print ('Pattern storing took:', endTime-startTime)         #####   #### ####  def patternRecognition():     #mostRecentPoint = avgLine[-1]      patForRec = []      cp1 = percentChange(avgLine[-11],avgLine[-10])     cp2 = percentChange(avgLine[-11],avgLine[-9])     cp3 = percentChange(avgLine[-11],avgLine[-8])     cp4 = percentChange(avgLine[-11],avgLine[-7])     cp5 = percentChange(avgLine[-11],avgLine[-6])     cp6 = percentChange(avgLine[-11],avgLine[-5])     cp7 = percentChange(avgLine[-11],avgLine[-4])     cp8 = percentChange(avgLine[-11],avgLine[-3])     cp9 = percentChange(avgLine[-11],avgLine[-2])     cp10= percentChange(avgLine[-11],avgLine[-1])      patForRec.append(cp1)     patForRec.append(cp2)     patForRec.append(cp3)     patForRec.append(cp4)     patForRec.append(cp5)     patForRec.append(cp6)     patForRec.append(cp7)     patForRec.append(cp8)     patForRec.append(cp9)     patForRec.append(cp10)      print (patForRec)       def graphRawFX():     fig=plt.figure(figsize=(10,7))      ax1 = plt.subplot2grid((40,40), (0,0), rowspan=40, colspan=40)     ax1.plot(date,bid)     ax1.plot(date,ask)     ####     ax1.plot(date,percentChange(ask[0],ask),'r')     ax1.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d %H:%M:%S'))     ####     plt.grid(True)     for label in ax1.xaxis.get_ticklabels():             label.set_rotation(45)     plt.gca().get_yaxis().get_major_formatter().set_useOffset(False)     #######     ax1_2 = ax1.twinx()     ax1_2.fill_between(date, 0, (ask-bid), facecolor='g',alpha=.3)      plt.subplots_adjust(bottom=.23)          plt.show()   graphRawFX()",True
@TheOlderSoldier,2019-03-13T00:12:27Z,1,"Do you think it would be possible to recognize a pattern in the output of a random seed? Example: system randomly generates a number between 0-9, AI guesses the next output based on past information.",True
@shreyashmehta7885,2018-07-05T13:01:51Z,0,why we have taken y=11 is it fixed?,True
@shreyashmehta7885,2018-07-05T13:01:23Z,1,outcomeRange = avgLine[y+20:y+30]         currentPoint = avgLine[y] please anyone can explain this lines of codes,True
@shreyashmehta7885,2018-07-05T12:56:51Z,0,why did we subtracted 30? in this code  x = len(avgLine)-30,True
@dauletkarakhanov742,2017-10-18T13:13:37Z,0,Got error: “TypeError: 'numpy.float64' object cannot be interpreted as an integer” Solved(hopefully) by changing one line to patForRec.append(float(cp1)) without touching the rest. Using Python3 and NumPy 1.12.1(blaming new version). Thank you for tutorial.,True
@anon58973,2015-11-07T21:51:07Z,0,thank you for posting this. I've been teaching myself neutral nets and genetic algorithms for equity analysis and this is very helpful.,True
@cornershop5268,2014-09-09T08:11:32Z,0,"Hi sentdex,  Great tutorials! Just wondering when you calculate cp1, cp2, cp3, ... and the subsequent percentage change between avgLine[-11] and avgLine[-10] ect..., the array loops around itself. Doesn't that mean if you are using the starting point i.e. avgLine[0] then the data avgLine[-11], avgLine[-10], ... represents data at the end of the day and not data prior to this point of time (since we are tabulating data for just 1 day)? Hope this questions makes sense. ",True
@sentdex,2013-10-13T18:56:23Z,3,"Personally, I am more of a fundamental investor myself. I just enjoy programming and machine learning. This whole series here doesn't use sentiment analysis at all. For my website, that is pure sentiment, and that is my main focus in business.   As for books, I don't know. Quant traders are an elusive bunch. The ones that make money don't talk much about how they do it.   The way I personally learn is to be like a sponge and absorb all i can, mostly from online documents.  Best wishes!",True
@haditime1665,2013-10-13T18:09:50Z,0,"hi your work in really great! i love markets and i know some python and machine learning,but i cant find any book that teach me what you do. can you show me the road map,books or what ever i need to know about market prediction? do you use any time series analysis or just sentiment analysis? anyway tnx for what u do here!",True
