author,updated_at,like_count,text,public
@GregMcRegor,2024-05-24T13:43:47Z,0,"Ay ay ay you procured reduce out of nowhere, how did that happen?",True
@ProgrammingWithRook,2023-11-20T00:47:26Z,1,"Hello Harrison, Please Read! as this has kept me busy, debugging ha And anyone else Who has inverted Images  Okay within the video, you're printing eachPix with 5 second delay, they are uint-8  ( for those who do don't know, uint-8 has a max value 0xFF | 255 ), so you're not getting the true values of the future calculations, when using lambda function, it does seem that the calculations are being done in uint-8 format then being converted to float-64 array via reduce? ( i don't know, this has taken me longer then I would like to admit, a few days, but I have been playing with the kinect Ir/depth sensors). For example:  for eachPix in eachRow:  avgNum = reduce(lambda x, y: x + y, eachPix[:3]) / len(eachPix[:3])  print((type(avgNum),avgNum,eachPix))  outputs Result: (<class 'numpy.float64'>, 80.33333333333333, array([255, 242,   0, 255], dtype=uint8))     <-------255+242+0 /3 != 80.3333333333  *changed the following was only for debugging* avgNum = reduce(lambda x, y: x + y, eachPix[:3]) / 1.0 # <1.0 debugging,   output Result :  (<class 'numpy.float64'>, 241.0, array([255, 242,   0], dtype=uint8))             <-------makes sense, 255+242+0 = 241 /1.0 =241.0   Adding ,dtype=numpy.uint16 to the image:  aImage3 = threshold1(numpy.array(image3, dtype=numpy.uint16)) and reverting back to:  avgNum = reduce(lambda x, y: x + y, eachPix[:3]) / len(eachPix[:3]) that you passthrough to the function you will get the correct Results:  (<class 'numpy.float64'>, 165.66666666666666, array([255, 242,   0, 255], dtype=uint16))    <--- 255 + 242 + 0 = 497 / 3 = 165.66666666666667  My image is still inverted, but we know now why, although I am not sure if this will change anything within the code, perhaps an additional check would need to be done on the four corners, if black then invert the whole image.  This will also clear the error message people was getting for the  Overflow at Runtime.   I did notice I wasn't getting no print/sysout until I closed the window, however that can wait until another day. one more thing, on your website, this tutorial - part 6, you have code from part 7, no biggie of course just helps anyone, who comes across the site.",True
@prateekagrawal2908,2020-05-10T18:39:10Z,0,"https://pythonprogramming.net/saving-image-data/?completed=/automated-image-thresholding-python/ .   Can you please try the python3 logic, I am getting the reverse output for a particular image i.e I am getting white in place of black and vice versa.",True
@rahultalekar4224,2019-10-05T08:26:06Z,0,"My code working but after using threshold function on iar1,2,3 in graph I get whole black image of iar1,2,3 please give me solution",True
@user-bn5zh1lp7x,2019-09-08T21:59:05Z,0,blance all over the place :D:D,True
@almostworthy2973,2019-08-17T06:25:23Z,1,"RuntimeWarning: overflow encountered in ubyte_scalars   avgNum = reduce(lambda x,y: x + y,eachpix[:3])/len(eachpix[:3])   I am getting this error in my code. I am using Python 3. I have used ""from functools import reduce"" . anyone with a solution?",True
@RAOROCKSTAR1990,2019-07-01T18:05:45Z,0,reduce not defined....Python version 3.7....solutions??,True
@adityatitus9522,2018-08-10T11:00:51Z,0,"if reduce(lambda x,y: x+y, each_pix[:3])/len(each_pix[:3]) > balance: ValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all() this is what im getting!! anyone have a solution to this?",True
@lindsay5985,2018-07-05T14:47:57Z,8,"If you get ""Line 30: ValueError: assignment destination is read-only"" (Python 2.7) try checking if you have used the wrong function around lines 40-50:  iar3 = np.asarray(i3) should be: iar3 = np.array(i3)",True
@chanukyalakamsani8898,2018-06-02T20:10:51Z,0,"Hi, Is it possible to recognize  a graph and extract the points points plotted",True
@androidjmurphyca,2018-04-23T23:21:54Z,0,"First great series. I was having an error with the reduce keyword so looking it up I came across: https://pythonprogramming.net/automated-image-thresholding-python/?completed=/thresholding-python-function/ I used the python 3 code which worked except the y05.png picture comes out inverse. I listed all the RGBA colors for the picture in a spread sheet to go step by step through the values along with the code.   The Mean value equals 199.4. Not done all of the videos yet so not sure if this will be an issue. Thanks again, learning a lot.",True
@rohitsinha7792,2018-03-08T21:23:04Z,0,great tutorial there. I tried running this code and got an error as mentioned below:  <ipython-input-22-0235982830de> in threshold(imageArray)      23       24             else: ---> 25                 eachPix[0] = 0      26                 eachPix[1] = 0      27                 eachPix[2] = 0  ValueError: assignment destination is read-only  It would be of great help if you can help me fix this. Thanks in advance,True
@Jsheng007,2018-01-30T16:45:47Z,0,"Hi sentdex, do you mind explain more about your formula for avgNum and balance? You can also point me to any related source which I could study myself. Thanks!",True
@tamaldas3544,2017-12-25T08:46:14Z,0,"giving error ""ValueError: assignment destination is read-only"" ....i have used your pics in pythonprograming.net",True
@toutenunmot,2017-12-01T19:59:21Z,3,"To get the average of a list we can use `numpy.mean(list_name)`. In our case we imported numpy as np so we would Use:      average = np.mean(list_name). - I find it is much simpler than using the reduce function. Example:     l = [1,2,3,4]     average = np.mean(l[:3])     # average will be 2.0  In sentdex's example that would be for the pixel and for the image:     avgNum = np.mean(eachPixel[:3])     balance = np.mean(balanceAr)  .",True
@SagarKumar-jz1wq,2017-10-08T10:01:19Z,0,Why does we leave eachPix[3] = 255 in the else portion of the program ?? Should it not be set to zero.. Please Help !,True
@OlegKorsak,2017-09-12T22:40:08Z,0,you have a wrong threshold for iar3 ! it should be inverted,True
@saminchowdhury7995,2017-03-23T15:28:56Z,2,Why did you use reduce instead of sum()?,True
@aHardReset,2017-01-29T17:48:17Z,0,"Why reduce lambda for the first three elements in the list:  [255 242   0 255] #First pixel in an Image returns: 241 don't should will return the sum of: 255+242+0 ? #reduce(lambda x, :x+y, eachPixel[:3]) please help... I'm doing the operations in my notebook but python says 241/3 and I say (255+242)/3 #I know... python is right but I don't know why",True
@pratik6447,2017-01-16T18:29:56Z,0,"Hi, i'm using Python 3.6   The error is : TypeError: can't convert type 'ndarray' to numerator/denominator  def threshold(imArray): # It will make image pure black or white     balanceArray = []     newArray=imArray     for eachRow in imArray:         for eachPix in eachRow:             print (eachPix)             #avgNum= reduce(lambda x,y : x+y, eachPix[:3])/len(eachPix[:3])             avgNum= mean(eachPix[:3])             print (avgNum)             balanceArray.append(avgNum)             print (balanceArray)     balance=mean(balanceArray)     print(type(balance))     print(type(mean(eachPix[:3])))     #print(""The balance is:"",balance,type(balance))       for eachRow in newArray:         for eachPix in newArray:             # if reduce(lambda x,y : x+y, eachPix[:3])/len(eachPix[:3]) > balance:              if mean(eachPix[:3]) > balance:                 eachPix[0]=255                 eachPix[1]=255                 eachPix[2]=255                 eachPix[3]=255              else:                 eachPix[0]=0                 eachPix[1]=0                 eachPix[2]=0                 eachPix[3]=255     return(newArray)",True
@steve__j,2016-12-16T02:45:21Z,1,"Warning (from warnings module):   File ""C:\Users\Steve\Documents\Python\imagerec.py"", line 12     avgNum = reduce(lambda x, y: x + y, eachPix[:3])/len(eachPix[:3]) RuntimeWarning: overflow encountered in ubyte_scalars  Warning (from warnings module):   File ""C:\Users\Steve\Documents\Python\imagerec.py"", line 14     balance = reduce(lambda x, y:  x + y, eachPix[:3])/len(balanceAr) RuntimeWarning: overflow encountered in ubyte_scalars  Warning (from warnings module):   File ""C:\Users\Steve\Documents\Python\imagerec.py"", line 18     if reduce(lambda x, y: x + y, eachPix[:3])/len(eachPix[:3]) > balance: RuntimeWarning: overflow encountered in ubyte_scalars    I am using Python 2.7.12 (v2.7.12:d33e0cf91556, Jun 27 2016, 15:19:22) [MSC v.1500 32 bit (Intel)] on win32. Any ideas?",True
@samiasaman2524,2016-12-06T14:40:26Z,0,i have runtime error.. can anybody help?,True
@samiasaman2524,2016-12-06T13:21:54Z,2,can you tell me the function of reduce? i mean about its parameters and the output it gives..,True
@top10softhedecade83,2016-09-14T19:58:11Z,0,"from PIL import Image import numpy as np import matplotlib.pyplot as plt       def threshold(imageArray):         balanceAr = []             newAr = imageArray          for eachRow in imageArray:             for eachPix in eachRow:                 avgNum = reduce(lambda x, y: x + y, eachPix[:3])/len(eachPix[:3])                 balanceAr.append(avgNum)         balance = reduce(lambda x, y: x + y, balanceAr)/len(balanceAr)         for eachRow in newAr:            for eachPix in eachRow:                if reduce(lambda x, y: x + y , eachPix[:3])/len(eachPix[:3]) > balance:                    eachPix[0] = 255                    eachPix[1] = 255                    eachPix[2] = 255                    eachPix[3] = 255                 else:                    eachPix[0] = 0                    eachPix[1] = 0                    eachPix[2] = 0                    eachPix[3] = 255      return newAr                    i = Image.open('images/numbers/0.1.png') iar = np.array(i)  i2 = Image.open('images/numbers/y0.4.png') iar2 = np.array(i2)  i3 = Image.open('images/numbers/y0.5.png') iar3 = np.array(i3)  i4 = Image.open('images/sentdex.png') iar4 = np.array(i4)  threshold(iar3) threshold(iar4)  fig = plt.figure() ax1 = plt.subplot2grid((8,6), (0,0) , rowspan = 4, colspan = 3) ax2 = plt.subplot2grid((8,6), (4,0) , rowspan = 4, colspan = 3) ax3 = plt.subplot2grid((8,6), (0,3) , rowspan = 4, colspan = 3)         ax4 = plt.subplot2grid((8,6), (4,3) , rowspan = 4, colspan = 3)  ax1.imshow(iar) ax2.imshow(iar2) ax3.imshow(iar3) ax4.imshow(iar4)  plt.show()  Just ran this code and it shows ""Theres an error in program: unexpected indent"" Any solution ? Thanks in Advance",True
@ashishjaiswal2501,2016-06-25T12:24:47Z,0,"It says ""Reduce is not defined""",True
@DIYGUY999,2016-06-20T06:43:15Z,0,"Hey Harrison,i get an error when i type in eachPix[3]=255.Can you help me find out why its popping out?",True
@MattCamp,2016-04-01T15:38:55Z,0,"Not sure what is going on with my threshold function, works fine on the 0 images but not the logo image. When it goes to do the logo image it returns an all black image with a single white pixel at about  x=58 y=15. I ran the function on a random image I had on my computer and it worked fine. Any guess what is the problem?",True
@mohamedgabr4911,2016-03-02T18:41:50Z,0,"i am using x32 bit python, how can I get that to work? :(",True
@note380,2016-01-19T21:13:25Z,0,Hi my code is taking long execute,True
@danielgn6227,2015-11-06T16:39:05Z,0,"I'm getting a really strange error. When I try to run the script, it shows a window that says ""syntax error"" And the IDLE doesn't highlight anything.  Some time before that, I was getting the same error but it highlighted the "":"" in ""for eachRow in newAr:""  Also, I don't know how to use exactly the ""mean"" function.  Here is the code: http://pastebin.com/njrn0F1E",True
@caleb957,2015-09-08T11:47:16Z,7,"the ubyte_scalar overflow warnings are because the pixels are stored in a ubyte array (max value 255), but the reducer can exceed 255 during its calculation.  the program still works but you can remove the warnings by having it use a larger type instead (e.g. int): reduce(lambda x, y: int(x) + int(y), eachPix[:3])",True
@pianista88,2015-03-29T11:41:02Z,0,I've ported the code to Java if anyone doesn't not know about python: https://github.com/pianista215/toBlack,True
@Minzkraut,2015-02-03T10:40:02Z,1,"i keep getting this error: Warning (from warnings module):   File ""C:/Users/Minzkraut/Documents/MEGA/Python/Image recognition/imagerec.py"", line 13     avgNum = reduce(lambda x, y:x+y,eachPix[:3])/len(eachPix[:3]) RuntimeWarning: overflow encountered in ubyte_scalars Traceback (most recent call last):   File ""C:/Users/Minzkraut/Documents/MEGA/Python/Image recognition/imagerec.py"", line 45, in <module>     threshold(iar3)   File ""C:/Users/Minzkraut/Documents/MEGA/Python/Image recognition/imagerec.py"", line 16, in threshold     balance = (lambda x, y:x+y,balanceAr[:3])/len(balanceAr[:3]) TypeError: unsupported operand type(s) for /: 'tuple' and 'int' >>>   (code:from PIL import Image import numpy as np from functools import reduce import matplotlib.pyplot as plt import time  def threshold(imgArray):     balanceAr = []     newArray = imgArray      for eachRow in imgArray:         for eachPix in eachRow:             avgNum = reduce(lambda x, y:x+y,eachPix[:3])/len(eachPix[:3])             balanceAr.append(avgNum)                  balance = (lambda x, y:x+y,balanceAr[:3])/len(balanceAr[:3])          for eachRow in newAr:         for eachPix in eachRow:             if reduce(lambda x, y:x+y,eachPix[:3])/len(eachPix[:3]) > balance:                 eachPix[0] = 255                 eachPix[1] = 255                 eachPix[2] = 255                 eachPix[3] = 255             else:                 eachPix[0] = 0                 eachPix[1] = 0                 eachPix[2] = 0                 eachPix[3] = 255     return newAr       i = Image.open(""images/numbers/0.1.png"") iar = np.array(i)  i2 = Image.open(""images/numbers/y0.4.png"") iar2 = np.array(i2)  i3 = Image.open(""images/numbers/y0.5.png"") iar3 = np.array(i3)  i4 = Image.open(""images/sentdex.png"") iar4 = np.array(i4)  threshold(iar3)  fig = plt.figure() ax1 = plt.subplot2grid((8,6),(0,0),rowspan=4,colspan=3) ax2 = plt.subplot2grid((8,6),(4,0),rowspan=4,colspan=3) ax3 = plt.subplot2grid((8,6),(0,3),rowspan=4,colspan=3) ax4 = plt.subplot2grid((8,6),(4,3),rowspan=4,colspan=3)  ax1.imshow(iar) ax2.imshow(iar2) ax3.imshow(iar3) ax4.imshow(iar4)  plt.show() )",True
@stejaka,2014-11-16T10:06:17Z,2,"So, I've been following along and everything's working out well until we get to threshold(iar3), which should return me a picture of a black 0 on a white background.  What I'm getting is a white 0 on a black background.  I'm getting the same thing you are for the other times you used threshold, but on the y0.5.png image, I'm getting the opposite of what you're getting.  Any ideas on why that's happening?  From what I can tell, it looks like the portion of the y0.5.png that creates the 0 is a lighter yellow than the background, but on the other images, the background is lighter than the foreground.  If I use ""<"" in the if statement that determines if the pixel is above or below the balance threshold, I get the same image as you on y0.5.png, but I get the reverse for the two other images.",True
@rodrigoloza4263,2014-10-17T20:49:20Z,0,"I know it's not into the direct topic. However, would you be so nice to create a video in which you show how to make a gaussian filter for an image?? Please!",True
@tushant04,2014-07-22T00:12:49Z,1,"i didn`t understand this part avgNum = reduce(lamda x , y : x + y , eachPixel[:3])/len(eachPixel[:3]) would you please clarify me  eachPixel[:3] means from 0 to 2[i.e pix[0]+pix[1]+pix[2]] pixel but what x and y is",True
@arpitmaheshwari1,2014-06-25T11:46:17Z,7,"import numpy as np import matplotlib.pyplot as mp from PIL import Image as img import time i=img.open('images/numbers/y0.3.png') iar=np.asarray(i) i2=img.open('images/numbers/y0.4.png') iar2=np.asarray(i2)             i3=img.open('images/numbers/y0.5.png') iar3=np.asarray(i3)             i4=img.open('images/sentdex.png') iar4=np.asarray(i4)             def threshold(arr):     balance=[]     newarr=arr     for row in arr:         for pix in row:             avg=int(sum(pix[0:3])/3)             balance.append(avg)     bal=int(sum(balance)/len(balance))     for r in newarr:         for pixx in r:             if int(sum(pixx[0:3])/3)>=bal:                 pixx[0]=255                 pixx[1]=255                 pixx[2]=255                 pixx[3]=255             else :                 pixx[0]=0                 pixx[1]=0                 pixx[2]=0                 pixx[3]=255     return newarr              a=iar threshold(a)              fig=mp.figure() ax1=mp.subplot2grid((8,8),(0,0),rowspan= 4,colspan=4) ax2=mp.subplot2grid((8,8),(4,0),rowspan= 4,colspan=4) ax3=mp.subplot2grid((8,8),(0,4),rowspan= 4,colspan=4) ax4=mp.subplot2grid((8,8),(4,4),rowspan= 4,colspan=4)      ax1.imshow(iar) ax2.imshow(iar2) ax3.imshow(iar3) ax4.imshow(iar4) mp.show()  WITH THIS CODE IT IS SHOWING AN ERROR  File ""C:/Users/arpit/Desktop/projects/python27/image.py"", line 36, in <module> threshold(a) File ""C:/Users/arpit/Desktop/projects/python27/image.py"", line 25, in threshold    pixx[0]=255 ValueError: assignment destination is read-only  can you tell me why is this error happening. i have 32 bit machine though i think it does matter.",True
@vitortorres-,2014-03-23T11:34:51Z,2,"avgNum = functools.reduce(lambda x, y: x + y, eachPix[:3])/len(eachPix[:3])  RuntimeWarning: overflow encountered in ubyte_scalars  Warning (from warnings module):   File ""imagerecognition.py"", line 22     if functools.reduce(lambda x, y: x + y, eachPix[:3])/len(eachPix[:3]) > balance:  RuntimeWarning: overflow encountered in ubyte_scalars  :( help ?",True
@stephenbooth1292,2014-03-11T18:50:24Z,0,"Thank you for putting these videos out,  I find it wonderful to hear your thoughts as you code.  A hopefully quick question for you: My Python version (2.76 on Windows 8.0 64bit) is making a fuss every time it runs across one of the lines similar to:  avgNum = reduce(lambda x, y: x + y, eachPix[:3]) / len(eachPix[:3])  they produce runtime warnings that look like so:  RuntimeWarning:  overflow encountered in ubyte_scalars  which I gather is related to the mathing of data types as we are trying to take the color averages, so I was wondering if you could suggest an alternative?  PS.  The code does function despite the runtime warning.",True
@sentdex,2013-11-27T05:14:29Z,1,"Elliot, for some reason I am unable to respond to your comment via reply. The issue is you've probably left out the conversion away from a numpy array, since it was a read only array when read in. Did you do the conversion to newAr?  Could you possibly paste the full error code with the code it found?",True
@sentdex,2013-10-31T14:17:51Z,0,"Well, we didnt have to return anything. It is going through the array and editing that array. That's why you don't have to save it. ",True
