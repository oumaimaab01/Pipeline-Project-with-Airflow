author,updated_at,like_count,text,public
@jaydy71,2023-12-23T22:19:45Z,0,"I really like your simple approach, it's really easy to follow (so far at least). To measure pattern similarity, how about doing that by simply calculating their correlation? I'm sure numpy has a function for that.",True
@gauravkumartiwari936,2021-02-14T23:08:24Z,0,my valentine day gift from youtube â¤ï¸ðŸŽ‰ . Thanks for such an awesome content !,True
@aybber,2020-11-08T19:42:19Z,0,you probably heard this 29 times but here you go again for the 30th time: USE FOR LOOPS (jk great tutorial),True
@rubenvicente4677,2019-11-16T14:12:44Z,2,I did a loop and now I am reading the coments while he is copying. First time I am faster than sentdex,True
@Mahdi-ug1qy,2019-08-06T18:22:38Z,0,"me, everytime he scrolls down: ah shit here we go again...",True
@uploadxxl,2019-04-28T18:37:13Z,0,"Hmmm and i think the simularity is not done entirely correctly. If we think about it conceptually 100% - would mean that the numbers are completely the same, where 0% would mean that the numbers are completely different. Now doing 100.00 - {the percentChange} is inaccurate similarity check, cause the percentChange might be more than 100% so then the similarity would be a minus, which conceptually means wat? Its SUPER different? :D . I think the more proper way would be: instead of substracting just from a hundred we should substract from the percentChange of the lowest point and the highest point(in the patternArray , and maybe in the patternArray and the current array?), cause conceptually in the array those would be the actually completely different values. And then in the  if 'howSim > ' we would not be checking by a constant number, but by the actual percentage of the completely different value percentChange(the min max points percentChange) like howSim  > minMaxPercChange*0.7. Wat you guyz think?",True
@uploadxxl,2019-04-28T17:00:38Z,0,"Hmmmm i dunno about returning that percentChange as 0.000000001 . I think It would be more accurate to just change the startPoint to the closest to 0 value before dividing by it, i'm trying sth like this: stPoint = startPoint if startPoint != 0 else 0.00000000000000000001. Cause with this percentChange formula of ours, the currentPoint can be 0, and it would yield more accurate results, if it would stay 0. What you guyz think?",True
@highlewelt9471,2018-08-23T17:20:20Z,0,"To make it with loops:  --> in patternStorage() pChanges = list()         for i in reversed(range(30)):             pi = percentChange(avgLine[y-30], avgLine[y-i])             pChanges.append(pi)  def currentPattern():     global patForRec     pChanges = list()     for i in reversed(range(1,30+1)):         pi = percentChange(avgLine[-31], avgLine[-i])         pChanges.append(pi)          patForRec.extend(pChanges)  def avg(l):     return sum(l) / float(len(l))  def patternRecognition():     for eachPattern in patternAr:         sims = list()         for i in range(30):             sim = 100 - abs(percentChange(eachPattern[i], patForRec[i]))             sims.append(sim)          howSim = avg(sims)          if howSim > 75:             patdex = patternAr.index(eachPattern)             print('#'*10)             print(patForRec)             print('='*5)             print(eachPattern)             print('='*5)             print('predicted outcome',performanceAr[patdex])             print('#'*10)",True
@fanel1900toamna,2018-08-11T02:45:35Z,0,"Hi and thanks for the tutorial series, great work! Based on the code I've seen so far I assume this would be the correct way to define x and outcome_range:  #assume pattern_size to be 10 or 30  min_peek = 20 x = len(avg_line) - (min_peek + pattern_size)  outcome_range = avg_line[y + min_peek:y + min_peek + pattern_size]    Would this be correct?",True
@StillOnMars,2018-02-05T23:05:46Z,0,"Of course he would've used for loops if he had programmed it for himself. Everyone knows how to use for loops you morons. He stated many times in his videos that he's doing it for the sake of clarity and I agree with this, it's much easier to understand the code this way. But what i didn't understand however is why you had to wrap try catch around percentChange method? I know you gave an explanation but I still can't see what might go wrong if percent change is 0 and why? Anyway, great videos!",True
@najoory,2017-10-31T03:28:40Z,8,use loops i am begging you,True
@dauletkarakhanov742,2017-10-20T06:59:11Z,0,"Can somebody help me with loops and comprehensions?: I used: num = 29  for p in range(1, 31):                 p = percentChange(avgLine[y - 30], avgLine[y - num])      num -=1      pattern.append(p)      Which worked, but looks stupid. Should be one line comprehension which I cannot think off.  Thank you. Great videos!",True
@bg810113,2017-08-15T09:15:10Z,0,"Hi, I just have one doubt here that 'outcomeRange = avgLine[y + 20:y + 30]' this has to be changed to 'outcomeRange = avgLine[y + 30:y + 60]'. Because we are taking 30 samples now and I think output range should be changed accordingly. Could pleae check and let me know? And I just wanna say I really appreciate your lectures.",True
@bevanc9999,2017-06-10T22:28:39Z,0,"I made a version with a for loop after writing it out the long way and it was slower than declaring all the variables by half a second! haha. I tried with list comprehension, that was only a mild improvement. Interesting..",True
@pudicio4895,2017-04-16T18:49:10Z,0,you didn't know how to do the loop right?,True
@dagharr2,2016-08-20T19:36:34Z,0,"yikes! p19,p20,p21,p22.....  you do a lot with sliding windows over sequences so far...perhaps having a static ""window_size"" var somewhere and relying on something like:  def window(seq, n=2):     """"""Returns a sliding window (of width n) over data from the iterable.      s -> (s0,s1,...s[n-1]), (s1,s2,...,sn), ...     """"""     it = iter(seq)     result = tuple(islice(it, n))     if len(result) == n:         yield result     for elem in it:         result = result[1:] + (elem,)         yield result   to yield sliding windows of the iterable. then building/storing/analyzing/comparing your patterns with something like:  for i, (w, avg) in enumerate(zip(window(self.avg_line, n=self.window_size), self.avg_line)):     # XXX  Either way, awesome series! I'm having a lot of fun going through it.",True
@JuvilleBeats,2016-03-17T17:44:52Z,2,aaand twentyonetwentytwotwentythreetwentyfour lol,True
@zhubarb,2015-06-25T12:35:23Z,28,"dude, you need some for loops in your life. :)",True
@flip550,2015-05-28T03:16:56Z,0,"Question: Are you reeling all this off from memory? Do you do each part beforehand and leave the finished code open on a second monitor, then use that as reference? Does having 150+ lines of code start to confuse you/forget what each function does?  Or does this all just come with experience? And keep up the good work, I learn a lot from you",True
@juliansf,2014-10-26T15:14:34Z,2,"Thanks for the tutorial, Harrison. I really like it. =)Â  I'd like to point out that since you are not changing the outcome range, the value of x should remain the same. So, it should still be ""x = len(avgLine)-30"".",True
@Stu49583,2014-09-14T04:23:47Z,4,you really should have used a for loop from the beginning :),True
@antoniozeus4,2013-12-14T19:26:14Z,7,"guys - watch the full ad if you want to support sentdex! by watching the full ad, we help him keep making these videos. Show you support!",True
@ortzg,2013-12-01T15:47:20Z,1,"Would just want to point out that there might be a need to change the following line because the tick window of analysis changed from 10 to 30: ""outcomeRange = avgLine[y+20:y+30]"" ..Overall an awesome tutorial!",True
@dfrusdn,2013-10-16T20:04:34Z,0,"  11:24 A shorterï»¿ way to do this would be  xp=range(1,31) ",True
