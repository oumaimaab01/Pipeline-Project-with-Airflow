author,updated_at,like_count,text,public
@JmanBC,2023-11-26T01:46:45Z,0,"Code for python 3.11  import matplotlib.pyplot as plt import matplotlib.ticker as mticker import matplotlib.dates as mdates import numpy as np from matplotlib import style import time from functools import reduce np.seterr(divide='ignore', invalid='ignore')  style.use(""ggplot"")  totalStart = time.time() date,bid,ask = np.genfromtxt('D:\Python\data\GBPUSD1d.txt', unpack=True,                               delimiter=',',                               converters={0: mdates.datestr2num})  avgLine = ((bid+ask)/2)  ####DEFINE###### #CHANGE# patternAr = [] performanceAr = [] patForRec = [] patForRec = []  def percentChange(startPoint,currentPoint):     try:         return ((float(currentPoint)-float(startPoint))/abs(startPoint))*100.00     except:         return 0  def patternStorage():     '''     The goal of patternFinder is to begin collection of %change patterns     in the tick data. From there, we also collect the short-term outcome     of this pattern. Later on, the length of the pattern, how far out we     look to compare to, and the length of the compared range be changed,     and even THAT can be machine learned to find the best of all 3 by     comparing success rates.     '''     ####     startTime = time.time()          x = len(avgLine)-30     y = 11     currentStance = 'none'          while y < x:         pattern = []         p1 = percentChange(avgLine[y-10], avgLine[y-9])         p2 = percentChange(avgLine[y-10], avgLine[y-8])         p3 = percentChange(avgLine[y-10], avgLine[y-7])         p4 = percentChange(avgLine[y-10], avgLine[y-6])         p5 = percentChange(avgLine[y-10], avgLine[y-5])         p6 = percentChange(avgLine[y-10], avgLine[y-4])         p7 = percentChange(avgLine[y-10], avgLine[y-3])         p8 = percentChange(avgLine[y-10], avgLine[y-2])         p9 = percentChange(avgLine[y-10], avgLine[y-1])         p10= percentChange(avgLine[y-10], avgLine[y])          outcomeRange = avgLine[y+20:y+30]         currentPoint = avgLine[y]         #Define##########################         #########change to try except for safety         try:             avgOutcome = reduce(lambda x, y: x + y, outcomeRange) / len(outcomeRange)         except Exception as e:             print (str(e))             avgOutcome = 0         #Define         futureOutcome = percentChange(currentPoint, avgOutcome)          #print some logics         '''         print 'where we are historically:',currentPoint         print 'soft outcome of the horizon:',avgOutcome         print 'This pattern brings a future change of:',futureOutcome         print '_______'         print p1, p2, p3, p4, p5, p6, p7, p8, p9, p10         '''          pattern.append(p1)         pattern.append(p2)         pattern.append(p3)         pattern.append(p4)         pattern.append(p5)         pattern.append(p6)         pattern.append(p7)         pattern.append(p8)         pattern.append(p9)         pattern.append(p10)           #can use .index to find the index value, then search for that value to get the matching information.         # so like, performanceAr.index(12341)         patternAr.append(pattern)         performanceAr.append(futureOutcome)                  y+=1         #####         endTime = time.time()         print (len(patternAr))         print (len(performanceAr))         print ('Pattern storing took:', endTime-startTime)         #####   #### ####  def currentPattern():     #mostRecentPoint = avgLine[-1]      cp1 = percentChange(avgLine[-11],avgLine[-10])     cp2 = percentChange(avgLine[-11],avgLine[-9])     cp3 = percentChange(avgLine[-11],avgLine[-8])     cp4 = percentChange(avgLine[-11],avgLine[-7])     cp5 = percentChange(avgLine[-11],avgLine[-6])     cp6 = percentChange(avgLine[-11],avgLine[-5])     cp7 = percentChange(avgLine[-11],avgLine[-4])     cp8 = percentChange(avgLine[-11],avgLine[-3])     cp9 = percentChange(avgLine[-11],avgLine[-2])     cp10= percentChange(avgLine[-11],avgLine[-1])      patForRec.append(cp1)     patForRec.append(cp2)     patForRec.append(cp3)     patForRec.append(cp4)     patForRec.append(cp5)     patForRec.append(cp6)     patForRec.append(cp7)     patForRec.append(cp8)     patForRec.append(cp9)     patForRec.append(cp10)      #print (patForRec)       def graphRawFX():     fig=plt.figure(figsize=(10,7))     ax1 = plt.subplot2grid((40,40), (0,0), rowspan=40, colspan=40)     ax1.plot(date,bid)     ax1.plot(date,ask)     ####     ax1.plot(date,percentChange(ask[0],ask),'r')     ax1.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d %H:%M:%S'))     ####     plt.grid(True)     for label in ax1.xaxis.get_ticklabels():             label.set_rotation(45)     plt.gca().get_yaxis().get_major_formatter().set_useOffset(False)     #######     ax1_2 = ax1.twinx()     ax1_2.fill_between(date, 0, (ask-bid), facecolor='g',alpha=.3)      plt.subplots_adjust(bottom=.23)          plt.show()   def patternRecognition():     for eachPattern in patternAr:         sim1 = 100.00 - abs(percentChange(eachPattern[0], patForRec[0]))         sim2 = 100.00 - abs(percentChange(eachPattern[1], patForRec[1]))         sim3 = 100.00 - abs(percentChange(eachPattern[2], patForRec[2]))         sim4 = 100.00 - abs(percentChange(eachPattern[3], patForRec[3]))         sim5 = 100.00 - abs(percentChange(eachPattern[4], patForRec[4]))         sim6 = 100.00 - abs(percentChange(eachPattern[5], patForRec[5]))         sim7 = 100.00 - abs(percentChange(eachPattern[6], patForRec[6]))         sim8 = 100.00 - abs(percentChange(eachPattern[7], patForRec[7]))         sim9 = 100.00 - abs(percentChange(eachPattern[8], patForRec[8]))         sim10 = 100.00 - abs(percentChange(eachPattern[9], patForRec[9]))         howSim = (sim1+sim2+sim3+sim4+sim5+sim6+sim7+sim8+sim9+sim10)/10.00          if howSim > 70:             patdex = patternAr.index(eachPattern)             print (patdex)                          print ('##################################')             print ('##################################')             print ('##################################')             print ('##################################')             print (patForRec)             print ('===================================')             print ('===================================')             print (eachPattern)             print ('----------')             print ('predicted outcome:',performanceAr[patdex])             print ('##################################')             print ('##################################')             print ('##################################')             print ('##################################')                              patternStorage() currentPattern() patternRecognition() totalEnd = time.time()-totalStart print ('Entire processing took:',totalEnd,'seconds')",True
@MythicalMysteryQuest,2020-10-22T19:23:31Z,1,Okay Its been 7 years. Are you a billionaire now?,True
@trandungediot,2020-03-25T23:53:54Z,1,"Can you turn on the subtitles of the video for me? You do not need to create subtitles, I will use YouTube's automatic translation function. Thankyou, Sincerely",True
@charlesglah5267,2019-04-30T13:02:02Z,0,ok so it seem the repo is not complete.  Can't use it.,True
@uploadxxl,2019-04-25T19:11:31Z,1,"Hello, i have a question why do we store the 'futureOutcome' as the percentChange between one element in the 'avgLine' array and the average of 10 elements in the '20 element future'? And then in the end we print these as the 'predicted outcome'(cause its used to form the performanceAr) , i don't understand how this 'futureOutcome' at some indexes is the 'predicted outcome'. The lines i'm talking about:  avgOutcome = reduce(lambda x, y: x+y, outcomeRange) / len(outcomeRange) currPoint = avgLine[y]   futureOutcome = percentChange(currPoint, avgOutcome) performanceAr.append(futureOutcome) print 'predicted outcome', performanceAr[patDex] .  Please help me out want to understand this fully :D .",True
@charlesglah5267,2019-04-24T12:27:02Z,0,Just downloaded the repository.  Need to watch all 10 videos again....so good.,True
@charlesglah5267,2019-04-24T03:15:33Z,1,Fascinating.  New to python and new to ML.  Seeking to implement pattern recognition into my trading algos.  Thanks for the videos.  Hopefully code will work in Python 3.7,True
@davidho2601,2018-12-19T12:35:42Z,0,"whats wrong with my code?   if I do this def percentChange(startPoint, currentPoint):     try:         x = ((float(currentPoint) - startPoint) / abs(startPoint)) * 100.00         print('x chg', 100.00 - abs(x))         if x == 0.0:             return 0.000000001         else:             return x     except ValueError as err:         return 0.00000000  The x chg looks right, but if I run this      for eachPattern in patternAr:         i = 0         simAccum = 0         while i < 30:             chg = percentChange(eachPattern[i], patForRec[i])             print('chg', chg)             simAccum += 100.00 - abs(chg)             i += 1          print('simAccum', simAccum)  The chg print does not match the prints for percentChange  - Original post by David Wynter",True
@kennethwong580,2018-12-06T18:57:37Z,0,"don't understand what's the problem hereeee  Warning (from warnings module):   File ""/Users/kennethwong/Desktop/Forex Bot/FXbot.py"", line 18     return ((float(currentPoint) - startPoint)/abs(startPoint))*100.00 RuntimeWarning: divide by zero encountered in double_scalars",True
@JeremyPizzolato,2018-10-23T15:28:34Z,0,"I'm getting an Typeerror: 'list' not callable on the line print('Predicted Outcome: ', performanceAr(patDex))",True
@FerMJy,2018-10-08T20:09:53Z,0,this is the most messy language i've ever seen you keep explaining.. but if the code has no logic at all... it's a waste of time,True
@liangyumin9405,2018-08-30T15:59:09Z,0,ennn... Maybe we should use enumerate and list sub for the loop body...,True
@ayush328,2017-01-21T02:00:03Z,0,Any idea about forecasting of foreign exchange rate?,True
@benliu9327,2015-08-16T15:57:36Z,1,"Hi, I went through step by step and got weird outcomes for patternRecognition(). When I calculated patterns, some elements (percentChange) of them are tiny small so that when I computed ""sim"",  some eachpattern[i] are relatively much smaller than patternForRec[i]. As a result, the corresponding percentChange(eachpattern[i],patternForRec[i]) is far more bigger than 100, and I got a lot of VERY negative values for sims. I checked the whole program and I don't know why I cannot get the similar results as yours   :(",True
@Jinex2010,2014-02-18T01:05:43Z,1,"So, I am currently developing this in QT C++. It took me 2 hours to discover that the abs() function applied on the startPoint in the percentChange function caused Nan error on every single computation ran by the paaternRecognition function. It was the fault of the Qt's abs() function. The std::abs() works fine! (#include <cmath>)",True
@antoniozeus4,2013-12-12T01:23:49Z,0,"i got a similar error as below - seems like I may be dividing by 0  File ""C:\Users\antoniozeus\Desktop\machinelearning.py"", line 22     return ((float(currentPoint - startPoint)/abs(startPoint)))*100.00 RuntimeWarning: divide by zero encountered in double_scalars",True
@MrLordoflyrics,2013-12-10T04:57:22Z,0,"I go through the whole process no errors but the predicted outcome is not printing.Only the current pattern, pattern storage takes to long and the pattern recognition doesn't print like it does for you. I don't see the lines in between etc.and this takes me 1004.8870008 seconds to print the whole process. while yours take 7 seconds, why?",True
@sentdex,2013-10-16T16:34:00Z,0,"Sounds like it was caught by a try and except. Probably just a pattern that wasn't filled in the first round or something. I went back and ran to see if I could find the error, and I couldn't Somewhere you're dividing by 0 and it's probably in one of the averaging lambda 1-liners. If you continue to see it, it'll probably cause problems down the line. Definitely want to figure out what is wrong.",True
@dfrusdn,2013-10-16T08:23:21Z,0,I continued further in the tutorial and it disappeared. very strange. The error was printed and skipped and I still got the same data come out.,True
@sentdex,2013-10-16T05:03:22Z,0,"Hmm, well, the first place to look would be in each of the places where we divide by an unknown #, or array. We do a lot of averaging  ... so it is probably happening there where it is dividing by a length of 0 because an array didn't get populated for some reason. I've run this for ~8,000 samples and not had the issue.  Are you having it immediately? or mid-way through? ",True
@dfrusdn,2013-10-16T04:51:38Z,0,Got the same results but I also have this error  in somewhere in PatternRecognition(). Can't figure out where.  module1:30: RuntimeWarning: divide by zero encountered in double_scalars,True
