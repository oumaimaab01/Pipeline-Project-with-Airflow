author,updated_at,like_count,text,public
@JoshCaiLovzu,2024-04-06T03:07:47Z,0,This simulation makes you think.... lol the system is rigged against bettor.,True
@AG-cx1ug,2022-01-25T17:48:13Z,0,7:03 The number of people playing shouldn't affect the chances of profit right? Only the about of wagers?,True
@AG-cx1ug,2022-01-25T17:38:13Z,0,"At 3:13, we append the wX and vY values under each if condition depending on whether rollDice is true or not. Shouldn't this be in the main while loop but after the if conditions? Inside the if conditions, wouldn't it mean wX gets appended every time the wager is done instead of the total value for every individual person?  If that is happening - since we get a line for each individual - how do we separate each individual?  Wouldn't wX look something like this: [person1value1, person1value2.. person2value1, person2value2...] How do we separate each person and so get different lines for them at 5:07?  Thank you so much!",True
@shantanugulawani9346,2020-05-26T15:21:45Z,0,"it is soo fun watching this series soo far, absolutely loving it",True
@savboo10,2019-09-23T23:54:09Z,3,Thank you so much for this series!! It's been very helpful for research/practice for my senior thesis this semester :D. Do you have any book recommendations?,True
@bg810113,2017-08-19T14:31:25Z,1,I don't understand the result.. Since the chance is 50:50 why does people end up losing money? Can someone explain reason?,True
@jeyaneepan,2017-06-20T19:29:46Z,0,"my prgram not working in python 3.6 import random import matplotlib import matplotlib.pyplot as plt def rollDice():     roll = random.randint(1,100)          if roll == 100:         #print(roll,'roll was 100,you lose. what are the odds?play again')         return False     elif roll <= 50:         #print(roll,'roll was 1-50, you loose.play again!')         return False     elif 100 > roll > 50:         #print(roll,'roll was 51-99, you win! *pretty light flash* play more')         return True def simple_bettor(funds,initial_wager, wager_count):     value = funds     wager = initial_wager     wX = []     vY = []          currentWager = 0     while currentWager <= wager_count:         if rollDice():             value += wager             wX.append(currentWager)             vY.append(value)         else:             value -= wager             wX.append(currentWager)             vY.append(value)     if value < 0:         value = 'broke'         currentWager += 1     #print('Funds',value)     plt.plot(wX,vY)           x = 0 while x < 100:          simple_bettor(10000, 100, 10)     x = x+1 plt.ylabel('Account Value') plt.xlabel('Wager Count') plt.show()",True
@miguelmedina2481,2017-06-01T17:16:15Z,0,"hello, i am using pycharm and my console does not show anything. do you know what happen? thank you",True
@JakeNelsonDooley,2016-03-09T18:33:06Z,1,sentdex these are great. either my computer and python are really slow or you're doing some editing on your video!,True
@torncky,2015-12-29T22:05:23Z,0,"Hey Sentdex,  Here is the deal. I tried to make simple montecarlo simulation for stock investments where you start with some investment value, investment period and mean and std of stock mutual fund. I also wanted to implement an easy way for stock market crash - I did it so that whenever new calculated value was for 40 % higher than previous one, the new value should fall for 90 % - like some kind of crash. I managed to make it working and here is the code, but I think that it is not working right. The problem is probably hidden where I call previous value. Could you try to make it working? I checked a lot of things but my knowledge is still limited.  Thanks!  Btw: Excelent page, youtube channel and videos. Everything I know about Python I learned from your site.  Best regards, David   import matplotlib import matplotlib.pyplot as plt import random import numpy as np  mean = 7.0 #mean for stock mutual fund std = 19.0 #std for stock mutual fund  def investment_return(): #random normal distribution of returns     investment_return = (np.random.normal(mean,std))/100     return investment_return  def investor(A, B):     investment_value = A     investment_period = B      wX = []     vY = []          x = 1             while x <= investment_period:         value = A + A*investment_return()         if value > value * 1.4: #if new value is 1.4x bigger than previous             A = value * 0.1 #than make -90 percent adjustment         else:             A = value #else use new value         wX.append(x)         vY.append(value)         x += 1     #print(value)      plt.plot(wX,vY)  i = 0 while i < 10: #number of investors     investor(100,20) #starting value and investment period     i += 1  plt.ylabel('Investment_value') plt.xlabel('Investment_period') plt.show()",True
@Minzkraut,2015-02-03T00:36:03Z,3,wow... it took me about 2h to get matplotlib to work because of numpy and all those damn packages ._.,True
@jeanfutebol,2014-03-23T01:50:17Z,0,"This is really cool, nice work!",True
